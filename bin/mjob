#!/usr/bin/env node
// -*- mode: js -*-
// Copyright (c) 2013, Joyent, Inc. All rights reserved.

var EventEmitter = require('events').EventEmitter;
var fs = require('fs');
var path = require('path');
var url = require('url');
var util = require('util');

var assert = require('assert-plus');
var backoff = require('backoff');
var bunyan = require('bunyan');
var cmdln = require('cmdln');
var LineStream = require('lstream');
var moment = require('moment');
var once = require('once');
var restify = require('restify');

var manta = require('../lib');



///--- Globals

var sprintf = util.format;

var JOB_DATA_FMT = '/%s/jobs/%s/%s.txt';

var LOG = bunyan.createLogger({
    name: path.basename(process.argv[1]),
    level: (process.env.LOG_LEVEL || 'info'),
    stream: process.stderr,
    serializers: restify.bunyan.serializers
});



///-- Helpers

function assertOpts(thisp, subcmd, opts, cb) {
    if (opts.help) {
        process.nextTick(function () {
            thisp.do_help('help', {}, [subcmd], cb.bind(thisp));
        });
        return (false);
    }

    try {
        manta.checkBinEnv(opts);
        manta.cli_logger(opts, LOG);
    } catch (e) {
        process.nextTick(cb.bind(thisp, e));
        return (false);
    }

    return (true);
}


function addInputsFromStdin(client, opts, cb) {
    assert.object(client, 'client');
    assert.object(opts, 'options');
    assert.number(opts.batch, 'options.batch');
    assert.arrayOfString(opts.jobIds, 'options.jobIds');
    assert.number(opts.parallel, 'options.parallel');
    assert.optionalBool(opts.open, 'options.open');
    assert.func(cb, 'callback');

    var lstream = new LineStream({
        encoding: 'utf8'
    });
    var queue = new manta.Queue({
        limit: opts.parallel,
        worker: function submit(keys, _cb) {
            _cb = once(_cb);

            var subQueue = new manta.Queue({
                limit: opts.parallel,
                worker: function _submit(id, __cb) {
                    __cb = once(__cb);
                    client.addJobKey(id, keys, function (err) {
                        if (err) {
                            __cb(err);
                            return;
                        }

                        if (!opts.quiet) {
                            console.error('added %d input%s to %s',
                                          keys.length,
                                          keys.length > 1 ? 's' : '',
                                          id);
                        }

                        __cb();
                    });
                }
            });

            subQueue.once('end', _cb);
            subQueue.once('error', _cb);

            opts.jobIds.forEach(subQueue.push.bind(subQueue));
            subQueue.close();
        }
    });
    var paused = false;
    var tmp = [];

    lstream.on('data', function onLine(l) {
        if (!l)
            return;

        tmp.push(manta.path(l, true));
        if (tmp.length === opts.batch) {
            if (!queue.push(tmp.slice(0)) && !paused) {
                queue.once('drain', function () {
                    lstream.resume();
                });
                paused = true;
                lstream.pause();
            }
            tmp.length = 0;
        }
    });

    lstream.once('end', function onInputEnd() {
        if (tmp.length > 0)
            queue.push(tmp.slice(0));
        tmp.length = 0;

        queue.close();
    });

    process.stdin.pipe(lstream);

    queue.once('end', function onKeysAdded() {
        function _cb(err) {
            client.close();
            cb(err);
        }

        if (!opts.open || opts.close) {
            var subQueue = new manta.Queue({
                limit: opts.parallel,
                worker: function end(id, __cb) {
                    client.endJob(id, once(__cb));
                }
            });

            subQueue.once('end', _cb);
            subQueue.once('error', _cb);

            opts.jobIds.forEach(subQueue.push.bind(subQueue));
            subQueue.close();
        } else {
            _cb();
        }
    });
}


function createClient(opts) {
    return (manta.createBinClient(opts));
}


// GetJob(Errors|Failures|Inputs|Outputs) all have the same logic
// So this is just a generic handler for those
function jobDataCommon(opts, callback) {
    assert.object(opts, 'options');
    assert.arrayOfString(opts.args, 'options.args');
    assert.object(opts.client, 'options.client');
    assert.string(opts.func, 'options.func');
    assert.number(opts.parallel, 'options.parallel');
    assert.string(opts.type, 'options.type');
    assert.string(opts.user, 'options.user');
    assert.string(opts.watch, 'options.watch');
    assert.optionalFunc(callback, 'callback');

    var queue = new manta.Queue({
        limit: opts.parallel,
        worker: function getJobData(id, cb) {
            cb = once(cb);

            opts.client[opts.func](id, function (err, out) {
                if (err) {
                    handleError(err);
                    return;
                }

                var body = '';

                out.once('error', cb);
                out.on(opts.watch, function (obj) {
                    if (opts.func === 'jobErrors') {
                        body += JSON.stringify(obj) + '\n';
                    } else if (opts.emit) {
                        opts.emit.emit(opts.watch, obj);
                    } else {
                        body += obj + '\n';
                    }
                });

                out.once('end', function () {
                    if (!opts.emit) {
                        process.stdout.write(body);
                        cb();
                    } else {
                        opts.emit.emit('end');
                    }
                });
            });
        }
    });

    queue.once('end', function () {
        if (callback) {
            opts.client.close();
            callback();
        }
    });
    queue.once('error', callback || function (err) {
        console.error('mjob: ' + err.toString());
        process.exit(1);
    });
    opts.args.forEach(queue.push.bind(queue));
    queue.close();
}


function jobWait(opts, cb) {
    assert.object(opts, 'options');
    assert.object(opts.client, 'options.client');
    assert.string(opts.id, 'options.id');
    assert.object(opts.opts, 'options.opts');
    assert.optionalObject(opts.baropts, 'options.baropts');
    assert.optionalBool(opts.catOutputOnError, 'options.catOutputOnError');
    assert.optionalFunc(cb, 'callback');

    if (!opts.opts.watch && !opts.opts.cat_outputs) {
        cb();
        return;
    }

    jobWatch({
        client: opts.client,
        job: opts.id,
        baropts: opts.baropts
    }, function (err, job) {
        if (err) {
            cb(err);
            return;
        }

        var s = job.stats;
        var job_error;
        if (s.errors > 0) {
            var msg = sprintf('job %s had %d error%s', opts.id, s.errors,
                              s.errors > 1 ? 's' : '');
            job_error = new Error(msg);
        }

        if (!opts.opts.cat_outputs) {
            cb(job_error);
        } else {
            if (job_error && !opts.catOutputOnError) {
                cb(job_error);
                return;
            }
            var ee = new EventEmitter();
            var outQueue = new manta.Queue({
                limit: 1,
                worker: function get(k, _cb) {
                    _cb = once(_cb);
                    opts.client.get(k, function (get_err, stream) {
                        if (get_err) {
                            _cb(get_err);
                            return;
                        }
                        stream.pipe(process.stdout, {end: false});
                        stream.once('end', _cb);
                    });
                }
            });

            function get_done(get_err) {
                opts.client.close();
                cb(get_err || job_error);
            }

            outQueue.once('end', get_done);
            outQueue.once('error', get_done);

            ee.on('key', outQueue.push.bind(outQueue));
            ee.once('end', outQueue.close.bind(outQueue));

            jobDataCommon({
                args: [opts.id],
                client: opts.client,
                emit: ee,
                func: 'jobOutput',
                parallel: opts.opts.parallel,
                type: 'out',
                user: opts.opts.account,
                watch: 'key'
            });
        }
    });
}


function jobWatch(opts, cb) {
    assert.object(opts);
    assert.string(opts.job, 'job');
    assert.object(opts.client, 'client');
    assert.optionalObject(opts.baropts, 'options.baropts');
    assert.func(cb, 'callback');

    cb = once(cb);

    var client = opts.client;
    var job = opts.job;

    var monitor = backoff.exponential({
        initialDelay: 100,
        maxDelay: opts.baropts ? 101 : 10000
    });

    var bar;
    var tasksDone;
    if (opts.baropts) {
        bar = new manta.ProgressBar(opts.baropts);
        tasksDone = 0;
    }

    monitor.on('ready', function onReady(attempts, delayms) {
        client.job(job, function onJob(err, status) {
            if (err) {
                monitor.reset(); // stop monitoring
                monitor.removeAllListeners('fail');
                monitor.removeAllListeners('ready');
                cb(err);
            } else if (status.state !== 'done' &&
                status.state !== 'archiving') {
                if (bar) {
                    bar.advance(status.stats.tasksDone - tasksDone);
                    tasksDone = status.stats.tasksDone;
                }
                monitor.backoff();
            } else {
                if (bar) {
                    bar.advance(status.stats.tasksDone - tasksDone);
                }
                monitor.reset(); // stop monitoring
                monitor.removeAllListeners('fail');
                monitor.removeAllListeners('ready');
                cb(null, status);
            }
        });
    });

    monitor.on('fail', function onFail() {
        cb(new Error(job + ' did not complete in time'));
    });

    monitor.backoff();
}


function getJobInfo(opts, cb) {
    assert.object(opts, 'options');
    assert.object(opts.client, 'options.client');
    assert.string(opts.id, 'options.id');
    assert.string(opts.user, 'options.user');
    assert.optionalFunc(cb, 'callback');

    cb = once(cb);
    opts.client.job(opts.id, cb);
}


///--- CLI

function MJob() {
    cmdln.Cmdln.call(this, {
        name: 'mjob',
        desc: 'Manages Manta compute jobs'
    });
}
util.inherits(MJob, cmdln.Cmdln);


//-- AddKeys

MJob.prototype.do_addinputs = function do_addinputs(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);
    opts.jobIds = args;
    addInputsFromStdin(client, opts, cb);
};

MJob.prototype.do_addinputs.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        names: ['batch', 'b'],
        type: 'positiveInteger',
        help: 'number of inputs to submit per batch (default 1000)',
        'default': 1000,
        helpArg: 'BATCH_SIZE'
    },
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations',
        'default': 25,
        helpArg: 'CONCURRENCY'
    },
    {
        names: ['open', 'o'],
        type: 'bool',
        help: 'leave job input open for adding more inputs',
        'default': false
    }
]);

MJob.prototype.do_addinputs.help = (
    'Adds inputs to an already created Manta Job.\n' +
        'Pipe inputs as \\n delimited paths\n' +
        'Example:\n' +
        /* JSSTYLED */
        '    mfind -t o /user/stor | mjob addinputs b19e0925-4c85-4fe9-ab47-8cc9dcfec81a\n' +
        '\n' +
        'Usage:\n' +
        '     mjob addinputs [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);


//-- CancelJob

MJob.prototype.do_cancel = function do_cancel(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);
    var queue = new manta.Queue({
        limit: opts.parallel,
        worker: function cancel(id, _cb) {
            client.cancelJob(id, _cb);
        }
    });

    queue.once('end', function () {
        client.close();
        cb();
    });
    queue.once('error', cb);
    args.forEach(queue.push.bind(queue));
    queue.close();
};

MJob.prototype.do_cancel.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations',
        'default': 100,
        helpArg: 'CONCURRENCY'
    }
]);

MJob.prototype.do_cancel.help = (
    'Cancels a Manta Job by JobId.\n' +
        'Example:\n' +
        '    mjob cancel f6e1391b-584d-4722-bbdf-4506621148c7\n' +
        '\n' +
        'Usage:\n' +
        '     mjob cancel [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);


//-- CreateJob

MJob.prototype.do_create = function create(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    var count = opts.count;
    var job = {
        name: opts.name,
        phases: []
    };

    if (opts.file) {
        var tmp = fs.readFileSync(path.normalize(opts.file), 'utf8');
        job = JSON.parse(tmp);
    } else if (opts.map || opts.reduce) {
        var next = {};
        opts._order.forEach(function (o) {
            switch (o.key) {
            case 'asset':
                next.assets = next.assets || [];
                next.assets.push(manta.path(o.value, true));
                break;
            case 'count':
                next.count = o.value;
                break;
            case 'disk':
                next.disk = o.value;
                break;
            case 'image':
                next.image = o.value;
                break;
            case 'init':
                next.init = o.value;
                break;
            case 'memory':
                next.memory = o.value;
                break;
            case 'map':
                job.phases.push({
                    assets: next.assets,
                    disk: next.disk,
                    exec: o.value,
                    image: next.image,
                    init: next.init,
                    memory: next.memory,
                    type: 'map'
                });
                next = {};
                break;
            case 'reduce':
                job.phases.push({
                    assets: next.assets,
                    count: next.count,
                    disk: next.disk,
                    exec: o.value,
                    image: next.image,
                    init: next.init,
                    memory: next.memory,
                    type: 'reduce'
                });
                next = {};
                break;
            default:
                break;
            }
        });

    } else if (args.length) {
        var exec = '';
        var type = 'map';

        function addPhase() {
            var p = {
                exec: exec,
                image: opts.image,
                type: type
            };

            if (type === 'reduce') {
                if (count > 1)
                    p.count = count;
            }

            count = opts.count;
            exec = '';

            job.phases.push(p);
        }

        for (var i = 0; i < args.length; i++) {
            if (args[i] === '^') {
                if (exec)
                    addPhase();
                type = 'map';
            } else if (/\^{2,}/.test(args[i])) {
                if (exec)
                    addPhase();
                count = args[i].length - 2 || count;
                type = 'reduce';
            } else {
                if (exec.length)
                    exec += ' ';

                exec += args[i];
            }

        }
        if (exec)
            addPhase();

        if (opts.asset) {
            var _assets = opts.asset.map(function (a) {
                return (manta.path(a));
            });
            job.phases.forEach(function (p) {
                p.assets = _assets;
            });
        }
    } else {
        cb(new Error('At least one map or reduce task must be specified'));
        return;
    }

    var client = createClient(opts);
    client.createJob(job, function (err, id) {
        if (err) {
            cb(err);
            return;
        }

        if (!opts.cat_outputs)
            console.log(id);

        if (process.stdin.isTTY) {
            if (!opts.close && !opts.open)
                console.error('mjob: warning: input stream left open');

            if (opts.close) {
                client.endJob(id, function onEndJob(err2) {
                    if (err2) {
                        cb(err2);
                        return;
                    }

                    jobWait({
                        client: client,
                        id: id,
                        opts: opts
                    }, cb);
                });
            } else {
                jobWait({
                    client: client,
                    id: id,
                    opts: opts
                }, cb);
            }
        } else {
            opts.jobIds = [id];
            addInputsFromStdin(client, opts, function (err2) {
                if (err2) {
                    cb(err2);
                    return;
                }
                jobWait({
                    client: client,
                    id: id,
                    opts: opts
                }, cb);
            });
        }
    });
};

MJob.prototype.do_create.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        names: ['batch', 'b'],
        type: 'positiveInteger',
        help: 'number of inputs to submit per batch (default 1000)',
        'default': 1000,
        helpArg: 'BATCH_SIZE'
    },
    {
        names: ['cat-outputs', 'o'],
        type: 'bool',
        help: 'wait for job to complete, then fetch outputs'
    },
    {
        names: ['close'],
        type: 'bool',
        help: 'do not leave job waiting for inputs'
    },
    {
        names: ['count'],
        type: 'positiveInteger',
        help: 'number of reducers to create',
        helpArg: 'REDUCERS',
        'default': 1
    },
    {
        names: ['disk'],
        type: 'positiveInteger',
        help: 'amount of disk space available for all phases (gigabytes)',
        helpArg: 'DISK_GB'
    },
    {
        names: ['memory'],
        type: 'positiveInteger',
        help: 'amount of memory available for all phases (megabytes)',
        helpArg: 'MEMORY_MB'
    },
    {
        names: ['file', 'f'],
        type: 'string',
        help: 'manifest file to create job from',
        helpArg: 'FILE'
    },
    {
        names: ['image'],
        type: 'string',
        help: 'Allowed compute image string (semver)',
        helpArg: 'IMAGE_SEMVER'
    },
    {
        names: ['init'],
        type: 'string',
        help: 'command to run before execution; must be valid bash script',
        helpArg: 'INIT_COMMAND'
    },
    {
        names: ['map', 'm'],
        type: 'arrayOfString',
        help: 'map phase(s)',
        helpArh: 'MAP_COMMAND'
    },
    {
        names: ['name', 'n'],
        type: 'string',
        help: 'job name',
        helpArg: 'NAME'
    },
    {
        names: ['open'],
        type: 'bool',
        help: 'leave job input open for adding more inputs',
        'default': false
    },
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations',
        'default': 25,
        helpArg: 'CONCURRENCY'
    },
    {
        names: ['quiet', 'q'],
        type: 'bool',
        help: 'do not output verbose information',
        'default': false
    },
    {
        names: ['reduce', 'r'],
        type: 'arrayOfString',
        help: 'reduce phase(s)',
        helpArh: 'REDUCE_COMMAND'
    },
    {
        names: ['asset', 's'],
        type: 'arrayOfString',
        help: 'asset(s) to place in zones',
        helpArg: 'ASSET_PATH'
    },
    {
        names: ['watch', 'w'],
        type: 'bool',
        help: 'wait for job to complete, and dump outputs'
    }
]);

MJob.prototype.do_create.help = (
    /* BEGIN JSSTYLED */
    'Creates a Manta Job.\n' +
        'You can create a job, feed inputs and wait for completion like this:\n' +
        'Example:\n' +
        '    mfind -t o /user/stor | mjob create "grep foo \|\| true" ^^ cat\n' +
        '\n' +
        'Usage:\n' +
        '     mjob create [OPTIONS] [map [^ map] [^^ reduce]]\n' +
        '\n' +
        '{{options}}'
    /* END JSSTYLED */
);


//-- GetJob
MJob.prototype.do_get = function do_get(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);
    var queue = new manta.Queue({
        limit: opts.parallel,
        worker: function getJob(id, _cb) {
            getJobInfo({
                client: client,
                id: id,
                user: opts.user
            }, function (err, job) {
                if (err) {
                    _cb(err);
                    return;
                }
                console.log('%s', JSON.stringify(job, null, 2));
                _cb();
            });
        }
    });

    queue.once('end', function () {
        client.close();
        cb();
    });
    queue.once('error', cb);
    args.forEach(queue.push.bind(queue));
    queue.close();
};

MJob.prototype.do_get.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations',
        'default': 100,
        helpArg: 'CONCURRENCY'
    }
]);

MJob.prototype.do_get.help = (
    'Retrieves the status of a Manta Job by JobId.\n' +
        'Example:\n' +
        '    mjob get f6e1391b-584d-4722-bbdf-4506621148c7\n' +
        '\n' +
        'Usage:\n' +
        '     mjob get [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);


//-- GetJobInputs

MJob.prototype.do_inputs = function do_inputs(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);
    jobDataCommon({
        args: args,
        client: client,
        func: 'jobInput',
        parallel: opts.parallel,
        type: 'in',
        user: opts.user,
        watch: 'key'
    }, cb);
};

MJob.prototype.do_inputs.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations',
        'default': 100,
        helpArg: 'CONCURRENCY'
    }
]);

MJob.prototype.do_inputs.help = (
    'Retrieves the inputs of a Manta Job by JobId.\n' +
        'Example:\n' +
        '    mjob inputs f6e1391b-584d-4722-bbdf-4506621148c7\n' +
        '\n' +
        'Usage:\n' +
        '     mjob inputs [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);

//-- GetJobOutputs

MJob.prototype.do_outputs = function do_outputs(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);
    jobDataCommon({
        args: args,
        client: client,
        func: 'jobOutput',
        parallel: opts.parallel,
        type: 'out',
        user: opts.user,
        watch: 'key'
    }, cb);
};

MJob.prototype.do_outputs.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations',
        'default': 100,
        helpArg: 'CONCURRENCY'
    }
]);

MJob.prototype.do_outputs.help = (
    'Retrieves the outputs of a Manta Job by JobId.\n' +
        'Example:\n' +
        '    mjob outputs f6e1391b-584d-4722-bbdf-4506621148c7\n' +
        '\n' +
        'Usage:\n' +
        '     mjob outputs [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);

//-- GetJobErrors

MJob.prototype.do_errors = function do_errors(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);
    jobDataCommon({
        args: args,
        client: client,
        func: 'jobErrors',
        parallel: opts.parallel,
        type: 'err',
        user: opts.user,
        watch: 'err'
    }, cb);
};

MJob.prototype.do_errors.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations',
        'default': 100,
        helpArg: 'CONCURRENCY'
    }
]);

MJob.prototype.do_errors.help = (
    'Retrieves the errors of a Manta Job by JobId.\n' +
        'Example:\n' +
        '    mjob errors f6e1391b-584d-4722-bbdf-4506621148c7\n' +
        '\n' +
        'Usage:\n' +
        '     mjob errors [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);


//-- GetJobFailures

MJob.prototype.do_failures = function do_failures(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);
    jobDataCommon({
        args: args,
        client: client,
        func: 'jobFailures',
        parallel: opts.parallel,
        type: 'fail',
        user: opts.user,
        watch: 'key'
    }, cb);
};

MJob.prototype.do_failures.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations',
        'default': 100,
        helpArg: 'CONCURRENCY'
    }
]);

MJob.prototype.do_failures.help = (
    'Retrieves the input failures of a Manta Job by JobId.\n' +
        'Example:\n' +
        '    mjob failures f6e1391b-584d-4722-bbdf-4506621148c7\n' +
        '\n' +
        'Usage:\n' +
        '     mjob failures [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);


//-- List

MJob.prototype.do_list = function do_list(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    var client = createClient(opts);

    client.listJobs(opts, function (err, res) {
        if (err) {
            cb(err);
            return;
        }

        var now = moment();
        res.on('job', function (j) {
            if (opts['long']) {
                var d = moment(j.mtime);
                var fmt = 'MMM D ';
                if (now.diff(d, 'months') >= 6) {
                    fmt += 'YYYY';
                } else {
                    fmt += 'HH:mm';
                }
                console.log('drwxr-xr-x 1 ' +
                            opts.user + ' 1 ' +
                            d.format(fmt) + ' ' +
                            j.name);
            } else {
                console.log(j.name + '/');
            }
        });

        res.once('error', cb);
        res.once('end', function () {
            client.close();
            cb();
        });
    });
};

MJob.prototype.do_list.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        names: ['name', 'n'],
        type: 'string',
        help: 'only list jobs with the given name',
        helpArg: 'NAME'
    },
    {
        names: ['long', 'l'],
        type: 'bool',
        help: 'use a long listing format'
    },
    {
        names: ['state', 's'],
        type: 'string',
        help: 'only list jobs in a given state',
        helpArg: 'STATE'
    }
]);

MJob.prototype.do_list.help = (
    'Lists all jobs.\n' +
        'Examples:\n' +
        '    mjob list -s running\n' +
        '    mjob list -n testjob\n' +
        '\n' +
        'Usage:\n' +
        '     mjob list [OPTIONS]\n' +
        '\n' +
        '{{options}}'
);

//-- Watch

MJob.prototype.do_watch = function do_watch(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);

    var queue = new manta.Queue({
        limit: opts.parallel,
        worker: function submit(j, _cb) {
            _cb = once(_cb);
            var _opts = {
                client: client,
                job: j
            };
            jobWatch(_opts, function (err, job) {
                if (err) {
                    _cb(err);
                    return;
                }

                console.log('%s', JSON.stringify(job, null, 2));
                _cb();
            });
        }
    });

    queue.once('error', cb);
    queue.once('end', function () {
        client.close();
        cb();
    });

    args.forEach(queue.push.bind(queue));
    queue.close();
};

MJob.prototype.do_watch.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations',
        'default': 100,
        helpArg: 'CONCURRENCY'
    }
]);

MJob.prototype.do_watch.help = (
    'Waits for a job to complete.\n' +
        'Example:\n' +
        '    mjob watch b19e0925-4c85-4fe9-ab47-8cc9dcfec81a\n' +
        '\n' +
        'Usage:\n' +
        '     mjob watch [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);



//-- Close

MJob.prototype.do_close = function do_close(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);

    var queue = new manta.Queue({
        limit: opts.parallel,
        worker: client.endJob.bind(client)
    });

    queue.once('error', cb);
    queue.once('end', function () {
        client.close();
        cb();
    });

    args.forEach(queue.push.bind(queue));
    queue.close();
};

MJob.prototype.do_close.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations',
        'default': 100,
        helpArg: 'CONCURRENCY'
    }
]);

MJob.prototype.do_close.help = (
    'End input for a job.\n' +
        'Example:\n' +
        '    mjob close b19e0925-4c85-4fe9-ab47-8cc9dcfec81a\n' +
        '\n' +
        'Usage:\n' +
        '     mjob close [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);



//-- ShareJob

MJob.prototype.do_share = function do_share(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length != 1) {
        cb(new Error('Exactly one JobId must be specified'));
        return;
    }

    var client = createClient(opts);
    var options = {};
    if (opts.readme)
        options.readme = opts.readme;

    client.jobShare(args[0], options, function (err, share) {
        if (err) {
            cb(err);
            return;
        }

        if (opts.stdout) {
            console.log(share.html);
            client.close();
            cb();
            return;
        }

        var dir = path.join('/', opts.user, 'public/jobshares',
            path.basename(args[0]));
        client.mkdirp(dir, function (err2) {
            if (err2) {
                cb(err2);
                return;
            }

            var tmp = path.join(dir, 'index.html');
            var stream = new manta.StringStream(share.html);
            options = { 'size': Buffer.byteLength(share.html, 'utf8') };
            client.put(tmp, stream, options, function (err3) {
                if (err3) {
                    cb(err3);
                    return;
                }

                var u = opts.url;
                console.log('%s',
                    u + (u[u.length - 1] == '/' ? tmp.substr(1) : tmp));
                client.close();
            });
        });
    });
};

MJob.prototype.do_share.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        names: [ 'stdout', 's' ],
        type: 'bool',
        'default': false,
        help: 'emit HTML to stdout instead of saving it to Manta'
    },
    {
        names: [ 'readme', 'r' ],
        type: 'string',
        help: 'Optional Markdown file to be rendered into the HTML output',
        helpArg: 'README'
    }
]);

MJob.prototype.do_share.help = (
    'Generate and upload an HTML page describing the job.\n' +
    'Example:\n' +
    '    mjob share b19e0925-4c85-4fe9-ab47-8cc9dcfec81a\n' +
    '\n' +
    'Usage:\n' +
    '    mjob share [OPTIONS] JobId\n' +
    '\n' +
    '{{options}}'
);



//-- JobCost

MJob.prototype.do_cost = function do_cost(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length != 1) {
        cb(new Error('Exactly one JobId must be specified'));
        return;
    }

    var version = '1.0.0';
    var assetsPath = '/manta/public/jobs/mjob-cost/' + version;
    var client = createClient(opts);
    var parts = manta.jobPath(args[0], opts.user).split('/');
    var user = parts[1];
    var id = parts[3];
    var jobManifest = {
        name: opts.name || 'mjobcost ' + args[0],
        phases: [
            {
                type: 'map',
                assets: [
                    assetsPath + '/billingComputeTable.json',
                    assetsPath + '/pricing.json',
                    assetsPath + '/jobcost.js'
                ],
                exec: sprintf('/assets%s/jobcost.js %s', assetsPath, id)
            },
            {
                type: 'reduce',
                exec: 'paste -sd+ | bc'
            }
        ]
    };

    function msToHour(ms) {
        return (Math.floor(ms / 3600000) * 3600000);
    }

    function constructPath(epochms) {
        function pad(n) {
            return (n < 10 ? '0' + n : n);
        }
        var d = new Date(epochms);
        var y = d.getUTCFullYear();
        var m = pad(d.getUTCMonth() + 1); // 0 = Jan, 11 = Dec
        var date = pad(d.getUTCDate());
        var h = pad(d.getUTCHours());
        return (sprintf('/%s/reports/usage/compute/%s/%s/%s/%s/h%s.json',
            user, y, m, date, h, h));
    }


    getJobInfo({
        client: client,
        id: id,
        user: user
    }, function onJob(err, jobInfo) {
        if (err) {
            cb(err);
            return;
        }

        if (jobInfo.stats.tasks === 0) {
            if (!opts.quiet)
                console.error('No tasks ran for ths job.');
            console.log('0');
            cb();
            return;
        }

        var start = msToHour(new Date(jobInfo.timeCreated).getTime());
        var end;
        var keys = [];

        if (!jobInfo.timeDone) {
            end = msToHour(Date.now());
        } else {
            end = msToHour(new Date(jobInfo.timeDone).getTime());
        }

        if (!opts.quiet && (end + 7200000 > Date.now())) {
            console.error('Warning: job was running in the past two hours. ' +
                'Compute usage reports may be missing for all ' +
                'or part of this job.');
        }

        while (start <= end) {
            keys.push(constructPath(start));
            start += 3600000;
        }

        client.createJob(jobManifest, function onCreateJob(err2, jobId) {
            if (err2) {
                cb(err2);
                return;
            }

            if (!opts.quiet)
                console.error(jobId);

            client.addJobKey(jobId, keys, function onAddKeys(err3, _job) {
                if (err3) {
                    cb(err3);
                    return;
                }

                if (!opts.quiet) {
                    console.error('added %d input%s to %s',
                                  keys.length,
                                  keys.length > 1 ? 's' : '',
                                  jobId);
                }

                client.endJob(jobId, function (err4) {
                    if (err4) {
                        cb(err4);
                        return;
                    }
                    opts.cat_outputs = true;
                    jobWait({
                        client: client,
                        id: jobId,
                        opts: opts,

                        // Sometimes the timeCreated-timeDone range includes
                        // time that the job was not actually running. This
                        // happens most often when a job is created but no
                        // input keys are added until later.
                        // In this case, we still want to print whatever cost
                        // that we got.
                        catOutputOnError: true
                    }, cb);
                });
            });
        });

    });
};

MJob.prototype.do_cost.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        names: ['name', 'n'],
        type: 'string',
        help: 'job name',
        helpArg: 'NAME'
    },
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations',
        'default': 25,
        helpArg: 'CONCURRENCY'
    },
    {
        names: ['quiet', 'q'],
        type: 'bool',
        help: 'do not output verbose information',
        'default': false
    }
]);

MJob.prototype.do_cost.help = (
    'Estimate the cost of a job in US dollars.\n' +
    '\n' +
    'Examples:\n' +
    '   $ mjob cost f6e1391b-584d-4722-bbdf-4506621148c7\n' +
    '   07be4a4c-520d-11e3-9cf4-fba37c5a3185\n' +
    '   added 3 inputs to 07be4a4c-520d-11e3-9cf4-fba37c5a3185\n' +
    '   $0.341\n' +
    '\n' +
    '   $ mjob cost f6e1391b-584d-4722-bbdf-4506621148c7 2>/dev/null\n' +
    '   $0.341\n' +
    '\n' +
    'Usage:\n' +
    '   mjob cost [OPTIONS] JobId\n' +
    '\n' +
    '{{options}}'
);

///--- Mainline

cmdln.main(MJob);
