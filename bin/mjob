#!/usr/bin/env node
// -*- mode: js -*-
/*
 * Copyright 2016 Joyent, Inc.
 */

var EventEmitter = require('events').EventEmitter;
var fs = require('fs');
var path = require('path');
var url = require('url');
var util = require('util');

var assert = require('assert-plus');
var backoff = require('backoff');
var bunyan = require('bunyan');
var cmdln = require('cmdln');
var LineStream = require('lstream');
var jsprim = require('jsprim');
var moment = require('moment');
var once = require('once');
var vasync = require('vasync');

var manta = require('../lib');



///--- Globals

var sprintf = util.format;

var JOB_DATA_FMT = '/%s/jobs/%s/%s.txt';

var NAME = path.basename(process.argv[1]);
var LOG = bunyan.createLogger({
    name: NAME,
    level: (process.env.LOG_LEVEL || 'info'),
    stream: process.stderr
});



///-- Helpers

function assertOpts(thisp, subcmd, opts, cb) {
    if (opts.help) {
        process.nextTick(function () {
            thisp.do_help('help', {}, [subcmd], cb.bind(thisp));
        });
        return (false);
    }

    manta.cliVersionCheckPrintAndExit(opts);

    try {
        manta.checkBinEnv(opts);
        manta.cli_logger(opts, LOG);
    } catch (e) {
        process.nextTick(cb.bind(thisp, e));
        return (false);
    }

    return (true);
}


function addInputsFromStdin(client, opts, cb) {
    assert.object(client, 'client');
    assert.object(opts, 'options');
    assert.finite(opts.batch, 'options.batch');
    assert.arrayOfString(opts.jobIds, 'options.jobIds');
    assert.finite(opts.parallel, 'options.parallel');
    assert.optionalBool(opts.open, 'options.open');
    assert.func(cb, 'callback');

    var lstream = new LineStream({
        encoding: 'utf8'
    });
    var queue = new manta.Queue({
        limit: opts.parallel,
        worker: function submit(keys, _cb) {
            _cb = once(_cb);

            var subQueue = new manta.Queue({
                limit: opts.parallel,
                worker: function _submit(id, __cb) {
                    __cb = once(__cb);
                    client.addJobKey(id, keys, function (err) {
                        if (err) {
                            __cb(err);
                            return;
                        }

                        if (!opts.quiet) {
                            console.error('added %d input%s to %s',
                                          keys.length,
                                          keys.length > 1 ? 's' : '',
                                          id);
                        }

                        __cb();
                    });
                }
            });

            subQueue.once('end', _cb);
            subQueue.once('error', _cb);

            opts.jobIds.forEach(subQueue.push.bind(subQueue));
            subQueue.close();
        }
    });
    var paused = false;
    var tmp = [];

    lstream.on('data', function onLine(l) {
        if (!l)
            return;

        tmp.push(manta.path(l, true));
        if (tmp.length === opts.batch) {
            if (!queue.push(tmp.slice(0)) && !paused) {
                queue.once('drain', function () {
                    lstream.resume();
                });
                paused = true;
                lstream.pause();
            }
            tmp.length = 0;
        }
    });

    lstream.once('end', function onInputEnd() {
        if (tmp.length > 0)
            queue.push(tmp.slice(0));
        tmp.length = 0;

        queue.close();
    });

    process.stdin.pipe(lstream);

    queue.once('end', function onKeysAdded() {
        if (!opts.open || opts.close) {
            var subQueue = new manta.Queue({
                limit: opts.parallel,
                worker: function end(id, __cb) {
                    client.endJob(id, once(__cb));
                }
            });

            subQueue.once('end', cb);
            subQueue.once('error', cb);

            opts.jobIds.forEach(subQueue.push.bind(subQueue));
            subQueue.close();
        } else {
            cb();
        }
    });
}


function createClient(opts) {
    return (manta.createBinClient(opts));
}


// GetJob(Errors|Failures|Inputs|Outputs) all have the same logic
// So this is just a generic handler for those
function jobDataCommon(opts, callback) {
    assert.object(opts, 'options');
    assert.arrayOfString(opts.args, 'options.args');
    assert.object(opts.client, 'options.client');
    assert.string(opts.func, 'options.func');
    assert.finite(opts.parallel, 'options.parallel');
    assert.string(opts.type, 'options.type');
    assert.string(opts.user, 'options.user');
    assert.string(opts.watch, 'options.watch');
    assert.optionalFunc(callback, 'callback');

    var queue = new manta.Queue({
        limit: opts.parallel,
        worker: function getJobData(id, cb) {
            cb = once(cb);

            function handleError(func_err) {
                if (func_err.statusCode !== 404) {
                    cb(func_err);
                    return;
                }

                var p = sprintf(JOB_DATA_FMT, opts.user, id, opts.type);
                opts.client.get(p, function (err, stream) {
                    if (err) {
                        cb(err);
                        return;
                    }

                    var body = '';
                    stream.setEncoding('utf8');
                    stream.on('data', function (chunk) {
                        body += chunk;
                    });
                    stream.once('end', function () {
                        process.stdout.write(body);
                        cb();
                    });
                });
            }

            opts.client[opts.func](id, function (err, out) {
                if (err) {
                    handleError(err);
                    return;
                }

                var body = '';

                out.once('error', handleError);
                out.on(opts.watch, function (obj) {
                    if (opts.func === 'jobErrors') {
                        body += JSON.stringify(obj) + '\n';
                    } else if (opts.emit) {
                        opts.emit.emit(opts.watch, obj);
                    } else {
                        body += obj + '\n';
                    }
                });

                out.once('end', function () {
                    if (!opts.emit) {
                        process.stdout.write(body);
                        cb();
                    } else {
                        opts.emit.emit('end');
                    }
                });
            });
        }
    });

    queue.once('end', function () {
        if (callback) {
            opts.client.close();
            callback();
        }
    });
    queue.once('error', callback || function (err) {
        console.error('mjob: ' + err.toString());
        process.exit(1);
    });
    opts.args.forEach(queue.push.bind(queue));
    queue.close();
}


function jobWait(opts, cb) {
    assert.object(opts, 'options');
    assert.object(opts.client, 'options.client');
    assert.string(opts.id, 'options.id');
    assert.object(opts.opts, 'options.opts');
    assert.optionalObject(opts.baropts, 'options.baropts');
    assert.optionalBool(opts.catOutputOnError, 'options.catOutputOnError');
    assert.optionalFunc(cb, 'callback');

    if (!opts.opts.watch && !opts.opts.cat_outputs) {
        cb();
        return;
    }

    jobWatch({
        client: opts.client,
        job: opts.id,
        baropts: opts.baropts
    }, function (err, job) {
        if (err) {
            cb(err);
            return;
        }

        var s = job.stats;
        var job_error;
        if (s.errors > 0) {
            var msg = sprintf('job %s had %d error%s', opts.id, s.errors,
                              s.errors > 1 ? 's' : '');
            job_error = new Error(msg);
        }

        if (!opts.opts.cat_outputs) {
            cb(job_error);
        } else {
            if (job_error && !opts.catOutputOnError) {
                cb(job_error);
                return;
            }
            var ee = new EventEmitter();
            var outQueue = new manta.Queue({
                limit: 1,
                worker: function get(k, _cb) {
                    _cb = once(_cb);
                    opts.client.get(k, function (get_err, stream) {
                        if (get_err) {
                            _cb(get_err);
                            return;
                        }
                        stream.pipe(process.stdout, {end: false});
                        stream.once('end', _cb);
                    });
                }
            });

            function get_done(get_err) {
                opts.client.close();
                cb(get_err || job_error);
            }

            outQueue.once('end', get_done);
            outQueue.once('error', get_done);

            ee.on('key', outQueue.push.bind(outQueue));
            ee.once('end', outQueue.close.bind(outQueue));

            jobDataCommon({
                args: [opts.id],
                client: opts.client,
                emit: ee,
                func: 'jobOutput',
                parallel: opts.opts.parallel,
                type: 'out',
                user: opts.opts.account,
                watch: 'key'
            });
        }
    });
}


function jobWatch(opts, cb) {
    assert.object(opts);
    assert.string(opts.job, 'job');
    assert.object(opts.client, 'client');
    assert.optionalObject(opts.baropts, 'options.baropts');
    assert.func(cb, 'callback');

    cb = once(cb);

    var client = opts.client;
    var job = opts.job;
    var accum = new JobStateAccumulator({
        'client': client,
        'log': client.log.child({ 'component': 'accum' }) /* XXX */
    });

    var monitor = backoff.exponential({
        initialDelay: 100,
        maxDelay: opts.baropts ? 101 : 2000
    });

    var bar;
    var tasksDone;
    if (opts.baropts) {
        bar = new manta.ProgressBar(opts.baropts);
        tasksDone = 0;
    }

    monitor.on('ready', function onReady(attempts, delayms) {
        client.job(job, function onJob(err, status) {
            if (err) {
                monitor.reset(); // stop monitoring
                monitor.removeAllListeners('fail');
                monitor.removeAllListeners('ready');
                cb(err);
            } else if (status.state !== 'done' &&
                status.state !== 'archiving') {
                accum.updateJobState(status);
                if (bar) {
                    bar.advance(status.stats.tasksDone - tasksDone);
                    tasksDone = status.stats.tasksDone;
                }
                monitor.backoff();
            } else {
                accum.on('end', function () {
                    cb(null, status);
                });
                accum.updateJobState(status);
                if (bar) {
                    bar.advance(status.stats.tasksDone - tasksDone);
                }
                monitor.reset(); // stop monitoring
                monitor.removeAllListeners('fail');
                monitor.removeAllListeners('ready');
            }
        });
    });

    monitor.on('fail', function onFail() {
        cb(new Error(job + ' did not complete in time'));
    });

    monitor.backoff();

    accum.on('jobError', function onNewJobError(err) {
        console.error('found new class of error: %s: %s',
            err.code, err.message);
    });
}


function getJobInfo(opts, cb) {
    assert.object(opts, 'options');
    assert.object(opts.client, 'options.client');
    assert.string(opts.id, 'options.id');
    assert.string(opts.user, 'options.user');
    assert.optionalFunc(cb, 'callback');

    cb = once(cb);
    opts.client.job(opts.id, function (err, job) {
        if (err) {
            if (err.statusCode !== 404) {
                cb(err);
            } else {
                var p = manta.jobPath(opts.id, opts.user) + '/job.json';
                opts.client.get(p, function (_err, stream) {
                    if (_err) {
                        cb(_err);
                    } else {
                        var body = '';
                        stream.setEncoding('utf8');
                        stream.on('data', function (chunk) {
                            body += chunk;
                        });
                        stream.once('end', function () {
                            cb(null, JSON.parse(body));
                        });
                    }
                });
            }
        } else {
            cb(null, job);
        }
    });
}


///--- CLI

function MJob() {
    cmdln.Cmdln.call(this, {
        name: 'mjob',
        desc: 'Manages Manta compute jobs',
        options: [
            {
                names: ['help', 'h'],
                type: 'bool',
                help: 'Show this help message and exit.'
            },
            {
                names: ['version'],
                type: 'bool',
                help: 'Print version and exit.'
            },
            {
                names: ['completion'],
                type: 'bool',
                help: 'Print bash completion code for this command and exit.',
                hidden: true
            }
        ],
        helpOpts: {
            includeEnv: true
        }
    });
}
util.inherits(MJob, cmdln.Cmdln);

MJob.prototype.init = function (opts, args, callback) {
    manta.cliVersionCheckPrintAndExit(opts);

    if (opts.completion) {
        /*
         * To ensure that all our stdout is written before 'process.exit()'
         * terminates, we set stdout to blocking. This is an issue when
         * (a) node v4 or later is used and (b) at least when exec'd by node
         * as in test/completion.test.js. See
         * https://gist.github.com/misterdjules/3aa4c77d8f881ffccba3b6e6f0050d03
         * for some discussion. An alternative would be to exit the the node
         * process without 'process.exit'.
         */
        if (process.stdout._handle &&
            typeof (process.stdout._handle.setBlocking) === 'function')
        {
            process.stdout._handle.setBlocking(true);
        }
        console.log(this.bashCompletion());
        process.exit(0);
    }

    cmdln.Cmdln.prototype.init.apply(this, arguments);
};

//-- AddKeys

MJob.prototype.do_addinputs = function do_addinputs(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);
    opts.jobIds = args;
    addInputsFromStdin(client, opts, function (err) {
        client.close();
        cb(err);
    });
};

MJob.prototype.do_addinputs.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        group: 'mjob addinputs options'
    },
    {
        names: ['batch', 'b'],
        type: 'positiveInteger',
        help: 'number of inputs to submit per batch (default 1000)',
        'default': 1000,
        helpArg: 'BATCH_SIZE'
    },
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations (default 25)',
        'default': 25,
        helpArg: 'NUM'
    },
    {
        names: ['open', 'o'],
        type: 'bool',
        help: 'leave job input open for adding more inputs',
        'default': false
    }
]);

MJob.prototype.do_addinputs.help = (
    'Adds inputs to an already created Manta Job.\n' +
        'Pipe inputs as \\n delimited paths\n' +
        'Example:\n' +
        /* JSSTYLED */
        '    mfind -t o /user/stor | mjob addinputs b19e0925-4c85-4fe9-ab47-8cc9dcfec81a\n' +
        '\n' +
        'Usage:\n' +
        '     mjob addinputs [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);


//-- CancelJob

MJob.prototype.do_cancel = function do_cancel(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);
    var queue = new manta.Queue({
        limit: opts.parallel,
        worker: function cancel(id, _cb) {
            client.cancelJob(id, _cb);
        }
    });

    queue.once('end', function () {
        client.close();
        cb();
    });
    queue.once('error', cb);
    args.forEach(queue.push.bind(queue));
    queue.close();
};

MJob.prototype.do_cancel.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        group: 'mjob cancel options'
    },
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations (default 100)',
        'default': 100,
        helpArg: 'NUM'
    }
]);

MJob.prototype.do_cancel.help = (
    'Cancels a Manta Job by JobId.\n' +
        'Example:\n' +
        '    mjob cancel f6e1391b-584d-4722-bbdf-4506621148c7\n' +
        '\n' +
        'Usage:\n' +
        '     mjob cancel [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);


//-- CreateJob

MJob.prototype.do_create = function create(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    var count = opts.count;
    var job = {
        name: opts.name,
        phases: []
    };

    if (opts.file) {
        var tmp = fs.readFileSync(path.normalize(opts.file), 'utf8');
        job = JSON.parse(tmp);
    } else if (opts.map || opts.reduce) {
        if (args.length > 0) {
                cb(new Error('cannot use -m/-r along with a job expression\n' +
                    '(did you forget a "-m" or "-r"?)'));
                return;
        }

        var next = {};
        opts._order.forEach(function (o) {
            switch (o.key) {
            case 'asset':
                next.assets = next.assets || [];
                next.assets.push(manta.path(o.value, true));
                break;
            case 'count':
                next.count = o.value;
                break;
            case 'disk':
                next.disk = o.value;
                break;
            case 'image':
                next.image = o.value;
                break;
            case 'init':
                next.init = o.value;
                break;
            case 'memory':
                next.memory = o.value;
                break;
            case 'map':
                job.phases.push({
                    assets: next.assets,
                    disk: next.disk,
                    exec: o.value,
                    image: next.image,
                    init: next.init,
                    memory: next.memory,
                    type: 'map'
                });
                next = {};
                break;
            case 'reduce':
                job.phases.push({
                    assets: next.assets,
                    count: next.count,
                    disk: next.disk,
                    exec: o.value,
                    image: next.image,
                    init: next.init,
                    memory: next.memory,
                    type: 'reduce'
                });
                next = {};
                break;
            default:
                break;
            }
        });

    } else if (args.length) {
        var exec = '';
        var type = 'map';

        function addPhase() {
            var p = {
                exec: exec,
                disk: opts.disk,
                image: opts.image,
                init: opts.init,
                memory: opts.memory,
                type: type
            };

            if (type === 'reduce') {
                if (count > 1)
                    p.count = count;
            }

            count = opts.count;
            exec = '';

            job.phases.push(p);
        }

        for (var i = 0; i < args.length; i++) {
            if (args[i] === '^') {
                if (exec)
                    addPhase();
                type = 'map';
            } else if (/\^{2,}/.test(args[i])) {
                if (exec)
                    addPhase();
                count = args[i].length - 2 || count;
                type = 'reduce';
            } else {
                if (exec.length)
                    exec += ' ';

                exec += args[i];
            }

        }
        if (exec)
            addPhase();

        if (opts.asset) {
            var _assets = opts.asset.map(function (a) {
                return (manta.path(a));
            });
            job.phases.forEach(function (p) {
                p.assets = _assets;
            });
        }
    } else {
        cb(new Error('At least one map or reduce task must be specified'));
        return;
    }

    if (opts.dry_run) {
        console.log(JSON.stringify(job, null, 4));
        cb();
        return;
    }

    var client = createClient(opts);
    client.createJob(job, function (err, id) {
        if (err) {
            cb(err);
            return;
        }

        if (!opts.cat_outputs)
            console.log(id);

        if (process.stdin.isTTY) {
            if (!opts.close && !opts.open)
                console.error('mjob: warning: input stream left open');

            if (opts.close) {
                client.endJob(id, function onEndJob(err2) {
                    if (err2) {
                        cb(err2);
                        return;
                    }

                    jobWait({
                        client: client,
                        id: id,
                        opts: opts
                    }, cb);
                });
            } else {
                jobWait({
                    client: client,
                    id: id,
                    opts: opts
                }, cb);
            }
        } else {
            opts.jobIds = [id];
            addInputsFromStdin(client, opts, function (err2) {
                if (err2) {
                    client.close();
                    cb(err2);
                    return;
                }
                jobWait({
                    client: client,
                    id: id,
                    opts: opts
                }, function (err3) {
                    client.close();
                    cb(err3);
                });
            });
        }
    });
};

MJob.prototype.do_create.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        group: 'mjob create options'
    },
    {
        names: ['batch', 'b'],
        type: 'positiveInteger',
        help: 'number of inputs to submit per batch (default 1000)',
        'default': 1000,
        helpArg: 'BATCH_SIZE'
    },
    {
        names: ['cat-outputs', 'o'],
        type: 'bool',
        help: 'wait for job to complete, then fetch outputs'
    },
    {
        names: ['close'],
        type: 'bool',
        help: 'do not leave job waiting for inputs'
    },
    {
        names: ['dry-run'],
        type: 'bool',
        help: 'Print the job configuration and exit, instead of '
            + 'creating the job.'
    },
    {
        names: ['name', 'n'],
        type: 'string',
        help: 'job name',
        helpArg: 'NAME'
    },
    {
        names: ['open'],
        type: 'bool',
        help: 'leave job input open for adding more inputs',
        'default': false
    },
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations (by mjob, not the job itself; '
            + 'default 25)',
        'default': 25,
        helpArg: 'NUM'
    },
    {
        names: ['quiet', 'q'],
        type: 'bool',
        help: 'do not output verbose information',
        'default': false
    },
    {
        names: ['watch', 'w'],
        type: 'bool',
        help: 'wait for job to complete, and dump outputs'
    },
    {
        group: 'Specify phases'
    },
    {
        names: ['file', 'f'],
        type: 'string',
        help: 'manifest file to create job from',
        helpArg: 'FILE'
    },
    {
        names: ['map', 'm'],
        type: 'arrayOfString',
        help: 'map phase(s)',
        helpArg: 'CMD'
    },
    {
        names: ['reduce', 'r'],
        type: 'arrayOfString',
        help: 'reduce phase(s)',
        helpArg: 'CMD'
    },
    {
        group: 'Phase properties'
    },
    {
        names: ['asset', 's'],
        type: 'arrayOfString',
        help: 'asset(s) to place in zones',
        helpArg: 'ASSET_PATH'
    },
    {
        names: ['count'],
        type: 'positiveInteger',
        help: 'number of reducers to create',
        helpArg: 'REDUCERS',
        'default': 1
    },
    {
        names: ['disk'],
        type: 'positiveInteger',
        help: 'amount of disk space available for a phase (gigabytes)',
        helpArg: 'DISK_GB'
    },
    {
        names: ['image'],
        type: 'string',
        help: 'Allowed compute image string (semver)',
        helpArg: 'IMAGE_SEMVER'
    },
    {
        names: ['init'],
        type: 'string',
        help: 'command to run before execution; must be valid bash script',
        helpArg: 'INIT_COMMAND'
    },
    {
        names: ['memory'],
        type: 'positiveInteger',
        help: 'amount of memory available for a phase (megabytes)',
        helpArg: 'MEMORY_MB'
    }
]);

MJob.prototype.do_create.help = [
    /* BEGIN JSSTYLED */
    'Create a Manta Job.',
    '',
    'Usage:',
    '    mjob create [OPTIONS] -m MAP [-m MAP] [-r REDUCE] ...  # option style',
    '    mjob create [OPTIONS] [MAP [^ MAP] [^^ REDUCE]]        # expression style',
    '    mjob create [OPTIONS] -f FILE                          # phases in JSON FILE',
    '',
    '{{options}}',
    'Map and reduce phases can be specified (a) via "-f FILE" with a job config',
    '(b) with "-m" and "-r" options:',
    '    mjob create -m "grep foo || true" -m "cut -d: -f1" -r cat',
    'or, (c) via an "expression" style using the "^" and "^^" syntax:',
    '    mjob create "grep foo || true" ^ "cut -d: -f1" ^^ cat',
    '',
    'Phase property options (--asset, --disk, etc.) apply differently depending on',
    'the usage type: if using options style (-m, -r), they apply to the *next* phase',
    'specified with -m/-r; if using expression style, they apply to *all* phases.',
    'For documentation on phase properties, including supported values for --disk',
    'and --memory see:',
    '    https://apidocs.joyent.com/manta/jobs-reference.html#job-configuration',
    '',
    'Input objects can be fed to a Manta job via stdin to `mjob create`:',
    '    mfind -t o ~~/stor/data | mjob create -m "grep foo || true" -r sort',
    'or via `mjob addinputs`:',
    '    jobId=$(mjob create -m "grep foo || true" -r sort)',
    '    mfind -t o ~~/stor/data | mjob addinputs $jobId'
    /* END JSSTYLED */
].join('\n');


//-- GetJob

MJob.prototype.do_get = function do_get(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);
    var queue = new manta.Queue({
        limit: opts.parallel,
        worker: function getJob(id, _cb) {
            getJobInfo({
                client: client,
                id: id,
                user: opts.user
            }, function (err, job) {
                if (err) {
                    _cb(err);
                    return;
                }
                console.log('%s', JSON.stringify(job, null, 2));
                _cb();
            });
        }
    });

    queue.once('end', function () {
        client.close();
        cb();
    });
    queue.once('error', cb);
    args.forEach(queue.push.bind(queue));
    queue.close();
};

MJob.prototype.do_get.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        group: 'mjob get options'
    },
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations (default 100)',
        'default': 100,
        helpArg: 'NUM'
    }
]);

MJob.prototype.do_get.help = (
    'Retrieves the status of a Manta Job by JobId.\n' +
        'Example:\n' +
        '    mjob get f6e1391b-584d-4722-bbdf-4506621148c7\n' +
        '\n' +
        'Usage:\n' +
        '     mjob get [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);


//-- GetJobInputs

MJob.prototype.do_inputs = function do_inputs(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);
    jobDataCommon({
        args: args,
        client: client,
        func: 'jobInput',
        parallel: opts.parallel,
        type: 'in',
        user: opts.user,
        watch: 'key'
    }, cb);
};

MJob.prototype.do_inputs.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        group: 'mjob inputs options'
    },
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations (default 100)',
        'default': 100,
        helpArg: 'NUM'
    }
]);

MJob.prototype.do_inputs.help = (
    'Retrieves the inputs of a Manta Job by JobId.\n' +
        'Example:\n' +
        '    mjob inputs f6e1391b-584d-4722-bbdf-4506621148c7\n' +
        '\n' +
        'Usage:\n' +
        '     mjob inputs [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);

//-- GetJobOutputs

MJob.prototype.do_outputs = function do_outputs(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);
    jobDataCommon({
        args: args,
        client: client,
        func: 'jobOutput',
        parallel: opts.parallel,
        type: 'out',
        user: opts.user,
        watch: 'key'
    }, cb);
};

MJob.prototype.do_outputs.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        group: 'mjob outputs options'
    },
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations (default 100)',
        'default': 100,
        helpArg: 'NUM'
    }
]);

MJob.prototype.do_outputs.help = (
    'Retrieves the outputs of a Manta Job by JobId.\n' +
        'Example:\n' +
        '    mjob outputs f6e1391b-584d-4722-bbdf-4506621148c7\n' +
        '\n' +
        'Usage:\n' +
        '     mjob outputs [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);

//-- GetJobErrors

MJob.prototype.do_errors = function do_errors(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);
    jobDataCommon({
        args: args,
        client: client,
        func: 'jobErrors',
        parallel: opts.parallel,
        type: 'err',
        user: opts.user,
        watch: 'err'
    }, cb);
};

MJob.prototype.do_errors.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        group: 'mjob errors options'
    },
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations (default 100)',
        'default': 100,
        helpArg: 'NUM'
    }
]);

MJob.prototype.do_errors.help = (
    'Retrieves the errors of a Manta Job by JobId.\n' +
        'Example:\n' +
        '    mjob errors f6e1391b-584d-4722-bbdf-4506621148c7\n' +
        '\n' +
        'Usage:\n' +
        '     mjob errors [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);


//-- GetJobFailures

MJob.prototype.do_failures = function do_failures(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);
    jobDataCommon({
        args: args,
        client: client,
        func: 'jobFailures',
        parallel: opts.parallel,
        type: 'fail',
        user: opts.user,
        watch: 'key'
    }, cb);
};

MJob.prototype.do_failures.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        group: 'mjob failures options'
    },
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations (default 100)',
        'default': 100,
        helpArg: 'NUM'
    }
]);

MJob.prototype.do_failures.help = (
    'Retrieves the input failures of a Manta Job by JobId.\n' +
        'Example:\n' +
        '    mjob failures f6e1391b-584d-4722-bbdf-4506621148c7\n' +
        '\n' +
        'Usage:\n' +
        '     mjob failures [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);


//-- List

MJob.prototype.do_list = function do_list(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    var client = createClient(opts);

    client.listJobs(opts, function (err, res) {
        if (err) {
            cb(err);
            return;
        }

        var now = moment();
        res.on('job', function (j) {
            if (opts['long']) {
                var d = moment(j.mtime);
                var fmt = 'MMM D ';
                if (now.diff(d, 'months') >= 6) {
                    fmt += 'YYYY';
                } else {
                    fmt += 'HH:mm';
                }
                console.log('drwxr-xr-x 1 ' +
                            opts.user + ' 1 ' +
                            d.format(fmt) + ' ' +
                            j.name);
            } else {
                console.log(j.name + '/');
            }
        });

        res.once('error', cb);
        res.once('end', function () {
            client.close();
            cb();
        });
    });
};

MJob.prototype.do_list.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        group: 'mjob list options'
    },
    {
        names: ['name', 'n'],
        type: 'string',
        help: 'only list jobs with the given name',
        helpArg: 'NAME'
    },
    {
        names: ['long', 'l'],
        type: 'bool',
        help: 'use a long listing format'
    },
    {
        names: ['state', 's'],
        type: 'string',
        help: 'only list jobs in a given state',
        helpArg: 'STATE'
    }
]);

MJob.prototype.do_list.help = (
    'Lists all jobs.\n' +
        'Examples:\n' +
        '    mjob list -s running\n' +
        '    mjob list -n testjob\n' +
        '\n' +
        'Usage:\n' +
        '     mjob list [OPTIONS]\n' +
        '\n' +
        '{{options}}'
);

//-- Watch

MJob.prototype.do_watch = function do_watch(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);

    var queue = new manta.Queue({
        limit: opts.parallel,
        worker: function submit(j, _cb) {
            _cb = once(_cb);
            var _opts = {
                client: client,
                job: j
            };
            jobWatch(_opts, function (err, job) {
                if (err) {
                    _cb(err);
                    return;
                }

                console.log('%s', JSON.stringify(job, null, 2));
                _cb();
            });
        }
    });

    queue.once('error', cb);
    queue.once('end', function () {
        client.close();
        cb();
    });

    args.forEach(queue.push.bind(queue));
    queue.close();
};

MJob.prototype.do_watch.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        group: 'mjob watch options'
    },
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations (default 100)',
        'default': 100,
        helpArg: 'NUM'
    }
]);

MJob.prototype.do_watch.help = (
    'Waits for a job to complete.\n' +
        'Example:\n' +
        '    mjob watch b19e0925-4c85-4fe9-ab47-8cc9dcfec81a\n' +
        '\n' +
        'Usage:\n' +
        '     mjob watch [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);



//-- Close

MJob.prototype.do_close = function do_close(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length < 1) {
        cb(new Error('At least one JobId must be specified'));
        return;
    }

    var client = createClient(opts);

    var queue = new manta.Queue({
        limit: opts.parallel,
        worker: client.endJob.bind(client)
    });

    queue.once('error', cb);
    queue.once('end', function () {
        client.close();
        cb();
    });

    args.forEach(queue.push.bind(queue));
    queue.close();
};

MJob.prototype.do_close.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        group: 'mjob close options'
    },
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations (default 100)',
        'default': 100,
        helpArg: 'NUM'
    }
]);

MJob.prototype.do_close.help = (
    'End input for a job.\n' +
        'Example:\n' +
        '    mjob close b19e0925-4c85-4fe9-ab47-8cc9dcfec81a\n' +
        '\n' +
        'Usage:\n' +
        '     mjob close [OPTIONS] JobId...\n' +
        '\n' +
        '{{options}}'
);



//-- ShareJob

MJob.prototype.do_share = function do_share(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length !== 1) {
        cb(new Error('Exactly one JobId must be specified'));
        return;
    }

    var client = createClient(opts);
    var options = {};
    if (opts.readme)
        options.readme = opts.readme;

    client.jobShare(args[0], options, function (err, share) {
        if (err) {
            cb(err);
            return;
        }

        if (opts.stdout) {
            console.log(share.html);
            client.close();
            cb();
            return;
        }

        var dir = path.join('/', opts.user, 'public/jobshares',
            path.basename(args[0]));
        client.mkdirp(dir, function (err2) {
            if (err2) {
                cb(err2);
                return;
            }

            var tmp = path.join(dir, 'index.html');
            var stream = new manta.StringStream(share.html);
            options = { 'size': Buffer.byteLength(share.html, 'utf8') };
            client.put(tmp, stream, options, function (err3) {
                if (err3) {
                    cb(err3);
                    return;
                }

                var u = opts.url;
                console.log('%s',
                    u + (u[u.length - 1] === '/' ? tmp.substr(1) : tmp));
                client.close();
            });
        });
    });
};

MJob.prototype.do_share.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        group: 'mjob share options'
    },
    {
        names: [ 'stdout', 's' ],
        type: 'bool',
        'default': false,
        help: 'emit HTML to stdout instead of saving it to Manta'
    },
    {
        names: [ 'readme', 'r' ],
        type: 'string',
        help: 'Optional Markdown file to be rendered into the HTML output',
        helpArg: 'README'
    }
]);

MJob.prototype.do_share.help = (
    'Generate and upload an HTML page describing the job.\n' +
    'Example:\n' +
    '    mjob share b19e0925-4c85-4fe9-ab47-8cc9dcfec81a\n' +
    '\n' +
    'Usage:\n' +
    '    mjob share [OPTIONS] JobId\n' +
    '\n' +
    '{{options}}'
);



//-- JobCost

MJob.prototype.do_cost = function do_cost(subcmd, opts, args, cb) {
    cb = once(cb);

    if (!assertOpts(this, subcmd, opts, cb))
        return;

    if (args.length !== 1) {
        cb(new Error('Exactly one JobId must be specified'));
        return;
    }

    var version = '1.0.0';
    var assetsPath = '/manta/public/jobs/mjob-cost/' + version;
    var client = createClient(opts);
    var parts = manta.jobPath(args[0], opts.user).split('/');
    var user = parts[1];
    var id = parts[3];
    var jobManifest = {
        name: opts.name || 'mjobcost ' + args[0],
        phases: [
            {
                type: 'map',
                assets: [
                    assetsPath + '/billingComputeTable.json',
                    assetsPath + '/pricing.json',
                    assetsPath + '/jobcost.js'
                ],
                exec: sprintf('/assets%s/jobcost.js %s', assetsPath, id)
            },
            {
                type: 'reduce',
                exec: 'paste -sd+ | bc'
            }
        ]
    };

    function msToHour(ms) {
        return (Math.floor(ms / 3600000) * 3600000);
    }

    function constructPath(epochms) {
        function pad(n) {
            return (n < 10 ? '0' + n : n);
        }
        var d = new Date(epochms);
        var y = d.getUTCFullYear();
        var m = pad(d.getUTCMonth() + 1); // 0 = Jan, 11 = Dec
        var date = pad(d.getUTCDate());
        var h = pad(d.getUTCHours());
        return (sprintf('/%s/reports/usage/compute/%s/%s/%s/%s/h%s.json',
            user, y, m, date, h, h));
    }


    getJobInfo({
        client: client,
        id: id,
        user: user
    }, function onJob(err, jobInfo) {
        if (err) {
            cb(err);
            return;
        }

        if (jobInfo.stats.tasks === 0) {
            if (!opts.quiet)
                console.error('No tasks ran for ths job.');
            console.log('0');
            cb();
            return;
        }

        var start = msToHour(new Date(jobInfo.timeCreated).getTime());
        var end;
        var keys = [];

        if (!jobInfo.timeDone) {
            end = msToHour(Date.now());
        } else {
            end = msToHour(new Date(jobInfo.timeDone).getTime());
        }

        if (!opts.quiet && (end + 7200000 > Date.now())) {
            console.error('Warning: job was running in the past two hours. ' +
                'Compute usage reports may be missing for all ' +
                'or part of this job.');
        }

        while (start <= end) {
            keys.push(constructPath(start));
            start += 3600000;
        }

        client.createJob(jobManifest, function onCreateJob(err2, jobId) {
            if (err2) {
                cb(err2);
                return;
            }

            if (!opts.quiet)
                console.error(jobId);

            client.addJobKey(jobId, keys, function onAddKeys(err3, _job) {
                if (err3) {
                    cb(err3);
                    return;
                }

                if (!opts.quiet) {
                    console.error('added %d input%s to %s',
                                  keys.length,
                                  keys.length > 1 ? 's' : '',
                                  jobId);
                }

                client.endJob(jobId, function (err4) {
                    if (err4) {
                        cb(err4);
                        return;
                    }
                    opts.cat_outputs = true;
                    jobWait({
                        client: client,
                        id: jobId,
                        opts: opts,

                        // Sometimes the timeCreated-timeDone range includes
                        // time that the job was not actually running. This
                        // happens most often when a job is created but no
                        // input keys are added until later.
                        // In this case, we still want to print whatever cost
                        // that we got.
                        catOutputOnError: true
                    }, cb);
                });
            });
        });

    });
};

MJob.prototype.do_cost.options = manta.DEFAULT_CLI_OPTIONS.concat([
    {
        group: 'mjob cost options'
    },
    {
        names: ['name', 'n'],
        type: 'string',
        help: 'job name',
        helpArg: 'NAME'
    },
    {
        names: ['parallel', 'p'],
        type: 'positiveInteger',
        help: 'limit concurrent operations (default 25)',
        'default': 25,
        helpArg: 'NUM'
    },
    {
        names: ['quiet', 'q'],
        type: 'bool',
        help: 'do not output verbose information',
        'default': false
    }
]);

MJob.prototype.do_cost.help = (
    'Estimate the cost of a job in US dollars.\n' +
    '\n' +
    'Examples:\n' +
    '   $ mjob cost f6e1391b-584d-4722-bbdf-4506621148c7\n' +
    '   07be4a4c-520d-11e3-9cf4-fba37c5a3185\n' +
    '   added 3 inputs to 07be4a4c-520d-11e3-9cf4-fba37c5a3185\n' +
    '   $0.341\n' +
    '\n' +
    '   $ mjob cost f6e1391b-584d-4722-bbdf-4506621148c7 2>/dev/null\n' +
    '   $0.341\n' +
    '\n' +
    'Usage:\n' +
    '   mjob cost [OPTIONS] JobId\n' +
    '\n' +
    '{{options}}'
);

/*
 * A JobStateAccumulator is an object that keeps track of the job's state over
 * time.  Callers invoke updateJobState() whenever they have an updated copy of
 * the job state.  This emits events:
 *
 *     'jobError'        whenever a new class of error is emitted by the job
 *                       The argument is an object describing the error, as it's
 *                       returned from the API.  This is not actually a
 *                       JavaScript error.
 *
 *     'end'             when the job has completed and no other events will be
 *                       emitted
 *
 * Errors cause warnings to be emitted to stderr, but do not get thrown or
 * propagated to the caller, since there's nothing to do but wait until we try
 * again next time.
 */
function JobStateAccumulator(args)
{
    assert.object(args, 'args');
    assert.object(args.client, 'args.client');
    assert.object(args.log, 'args.log');

    this.jsa_last = null;
    this.jsa_errors = {};
    this.jsa_fetching = false;
    this.jsa_pending = false;
    this.jsa_lasttime = false;
    this.jsa_client = args.client;
    this.jsa_log = args.log;

    EventEmitter.call(this);
}

util.inherits(JobStateAccumulator, EventEmitter);

/*
 * Update the job's state.  "job" should be the job's status, as returned by the
 * Manta API.
 *
 * If new errors are detected, we will fetch them, categorize them, and emit
 * "jobError" for errors that we have not seen before.
 */
JobStateAccumulator.prototype.updateJobState = function (job)
{
    var checkerrors = false;
    var prev = this.jsa_last;

    assert.object(job, 'job');
    assert.string(job.id, 'job.id');
    assert.string(job.state, 'job.state');
    assert.object(job.stats, 'job.stats');
    assert.number(job.stats.errors, 'job.stats.errors');
    assert.number(job.stats.outputs, 'job.stats.outputs');
    assert.number(job.stats.retries, 'job.stats.retries');
    assert.number(job.stats.tasks, 'job.stats.tasks');
    assert.number(job.stats.tasksDone, 'job.stats.tasksDone');

    this.jsa_log.trace({ 'job': job }, 'new job state');

    this.jsa_last = job;
    if (prev !== null && prev.state === 'done') {
        this.jsa_log.trace({ 'job': job }, 'was already done');
        return;
    }

    if (job.state == 'done' ||
        (prev !== null && job.stats.errors > prev.stats.errors)) {
        this.jsa_log.trace('will check errors');
        checkerrors = true;
    }

    if (job.state == 'done') {
        this.jsa_log.trace('last time');
        this.jsa_lasttime = true;
    }

    if (!checkerrors) {
        return;
    }

    if (this.jsa_fetching) {
        this.jsa_log.trace('already pending');
        this.jsa_pending = true;
        return;
    }

    this.jsa_fetching = true;
    this.fetchErrorDetails();
};

/*
 * [internal] Fetch list of errors for the job.
 */
JobStateAccumulator.prototype.fetchErrorDetails = function ()
{
    var jobid;
    var self = this;

    jobid = this.jsa_last.id;
    this.jsa_client.jobErrors(jobid, function onJobErrors(err, stream) {
        if (err) {
            /* TODO */
            /*
             * XXX probably shouldn't have updated "last" because we think we've
             * fetched the last error, but haven't.
             */
            console.error('warn: fetching job errors: %s', err.message);
            self.fetchDone();
            return;
        }

        stream.on('error', function onError(stream_error) {
            /* TODO */
            /* XXX see above */
            console.error('warn: processing job errors: %s',
                stream_error.message);
            self.fetchDone();
        });

        stream.on('end', function onEndErrors() {
            self.fetchDone();
        });

        stream.on('err', function onJobError(job_error) {
            self.fetchGotJobError(job_error);
        });
    });
};

/*
 * [internal] Invoked when a single fetch operation completes.
 */
JobStateAccumulator.prototype.fetchDone = function ()
{
    assert.ok(this.jsa_fetching);
    this.jsa_log.trace('fetch done');
    if (this.jsa_lasttime) {
        this.jsa_log.debug('last fetch done');
        this.emit('end');
    } if (this.jsa_pending) {
        this.jsa_log.trace('taking immediate lap');
        this.jsa_pending = false;
        this.fetchErrorDetails();
    } else {
        this.jsa_fetching = false;
    }
};

/*
 * [internal] Invoked when we found an error from the job.  This may be invoked
 * multiple times for the same error.
 */
JobStateAccumulator.prototype.fetchGotJobError = function (job_error)
{
    var key;

    /*
     * Right now, we group most errors by their code.  For UserTaskErrors, we
     * additionally group them by the message so that different exit statuses
     * are all reported.
     */
    assert.string(job_error.code, 'job_error.code');
    key = job_error.code == 'UserTaskError' ?
        job_error.code + '/' + job_error.message : job_error.code;

    if (jsprim.hasKey(this.jsa_errors, key)) {
        this.jsa_log.trace({ 'error': job_error }, 'dup error');
        return;
    }

    this.jsa_log.trace({ 'error': job_error }, 'new error');
    this.jsa_errors[key] = job_error;
    this.emit('jobError', job_error);
};

///--- Mainline

if (require.main === module) {
    var cli = new MJob();
    cmdln.main(cli, {
        showNoCommandErr: true
    });
}
