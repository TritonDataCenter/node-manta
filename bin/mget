#!/usr/bin/env node
// -*- mode: js -*-
/*
 * Copyright 2016 Joyent, Inc.
 */

var fs = require('fs');
var http = require('http');
var path = require('path-platform');
var url = require('url');
var util = require('util');

var bunyan = require('bunyan');
var dashdash = require('dashdash');

var manta = require('../lib');



///--- Globals

var NAME = path.basename(process.argv[1]);
var LOG = bunyan.createLogger({
    name: NAME,
    level: (process.env.LOG_LEVEL || 'info'),
    stream: process.stderr
});


var ENCRYPT_AUTH_MODES = ['MandatoryAuthentication', 'OptionalAuthentication'];

dashdash.addOptionType({
    name: 'encryptAuthMode',
    takesArg: true,
    helpArg: 'MODE',
    parseArg: function parseEncryptAuthMode(option, optstr, arg) {
        manta.encryptValidateAuthMode(arg);
        return (arg);
    }
});

var OPTIONS_PARSER = dashdash.createParser({
    options: manta.DEFAULT_CLI_OPTIONS.concat([
        {
            group: 'Client-side encryption options'
        },
        {
            names: ['decrypt', 'e'],
            type: 'bool',
            help: 'Expect the object to be encrypted, and decrypt it.'
        },
        {
            names: ['encrypt-key'],
            type: 'string',
            env: 'MANTA_ENCRYPT_KEY',
            helpArg: 'KEY',
            help: 'Base64 secret key for decrypting remote encrypted objects.'
        },
        {
            names: ['encrypt-auth-mode'],
            type: 'encryptAuthMode',
            env: 'MANTA_ENCRYPT_AUTH_MODE',
            helpArg: 'MODE',
            help: 'Whether decryption will enforce authentication '
                + '("MandatoryAuthentication", the default) or allow some '
                + 'operations, e.g. range requests, which cannot enforce '
                + 'authentication ("OptionalAuthentication")'
        },
        {
            group: NAME + ' options'
        },
        {
            names: ['header', 'H'],
            type: 'arrayOfString',
            help: 'HTTP headers to include',
            helpArg: 'HEADER'
        },
        {
            names: ['quiet', 'q'],
            type: 'bool',
            help: 'disable the progress bar'
        },
        {
            names: ['progress'],
            type: 'bool',
            help: 'force the progress bar to draw, even when stderr redirected'
        },
        {
            names: ['output', 'o'],
            type: 'string',
            help: 'write output to <file> instead of stdout'
        },
        {
            names: ['remote-name', 'O'],
            type: 'bool',
            help: 'write output to a file using remote object name as filename'
        },
        {
            names: ['include'],
            type: 'bool',
            help: 'Include the HTTP-header in the output.'
        }
    ])
});



///--- Functions

function ifError(err) {
    if (err) {
        console.error('mget: ' + err.toString());
        process.exit(1);
    }
}


function parseOptions() {
    var opts;

    try {
        opts = OPTIONS_PARSER.parse(process.argv);
        manta.checkBinEnv(opts);
    } catch (e) {
        manta.cli_usage(OPTIONS_PARSER, e.message, 'path...');
    }

    manta.cli_logger(opts, LOG);

    if (opts.help)
        manta.cli_usage(OPTIONS_PARSER, false, 'path...');

    manta.cliVersionCheckPrintAndExit(opts);
    manta.cliCompletionCheckPrintAndExit(opts, OPTIONS_PARSER, NAME, ['mpath']);

    if (opts._args.length < 1)
        manta.cli_usage(OPTIONS_PARSER, 'path required', 'path...');

    opts.paths = opts._args;

    if (opts.remote_name) {
        if (opts.paths.length !== 1) {
            manta.cli_usage(OPTIONS_PARSER, '--remote-name only works with ' +
              'a single object path', 'path...');
        } else {
            opts.output = path.posix.basename(opts.paths[0]);
        }
    }

    opts.headers = {};
    (opts.header || []).forEach(function (h) {
        if (h.indexOf(':') === -1) {
            manta.cli_usage(OPTIONS_PARSER,
                            'header must be in the form of "[header]: value"',
                            'path...');
        }
        var tmp = h.split(':');
        opts.headers[tmp[0]] = tmp[1].trim();
    });

    if (opts.decrypt) {
        if (!opts.encrypt_key) {
            manta.cli_usage(OPTIONS_PARSER, 'decryption requires ' +
                '--encrypt-key or the MANTA_ENCRYPT_KEY environment variable');
        }
        var base64Key = new Buffer(opts.encrypt_key, 'base64');
        opts.encrypt = {
            getKey: function (keyId, cb) {
                cb(null, base64Key);
            },
            authMode: opts.encrypt_auth_mode
        };
    }

    return (opts);
}


// The same as `printEntry` from minfo.
function printHeaders(res) {
    console.log('HTTP/%s %s %s',
                res.httpVersion,
                res.statusCode,
                http.STATUS_CODES[res.statusCode]);
    Object.keys(res.headers).forEach(function (k) {
        console.log('%s: %s', k, res.headers[k]);
    });
    console.log();
}


///--- Mainline

(function main() {
    var opts = parseOptions();
    var client = manta.createBinClient(opts);
    var i = -1;
    var out = process.stdout;
    var drawProgressBar = true;

    function get() {
        var p = opts.paths[++i];
        if (!p) {
            client.close();
            return;
        }

        client.get(p, function (err, stream, res) {
            ifError(err);

            if (opts.include) {
                printHeaders(res);
            }

            var bar;
            var src = stream;
            if (opts.progress || drawProgressBar) {
                var baropts = {
                    filename: p,
                    devtty: opts.progress
                };
                var clen =
                    parseInt(res.headers['content-length'],
                             10);
                if (clen >= 0) {
                    baropts.size = clen;
                } else {
                    baropts.nosize = true;
                }
                bar = new manta.ProgressBar(baropts);
                src = stream.pipe(bar.stream());
            }

            src.on('error', function (srcErr) {
                ifError(srcErr);
            });

            src.pipe(out);

            src.on('end', function () {
                get();
            });
        });
    }

    if (opts.quiet || !Boolean(process.stderr.isTTY))
        drawProgressBar = false;

    if (opts.output) {
        out = fs.createWriteStream(opts.output);
        out.on('open', get.bind(this));
    } else {
        if (out.isTTY) {
            /*
             * If we're outputting to a TTY, then we don't
             * want to draw the progress bar as it will likely
             * clobber the output.
             */
            drawProgressBar = false;
        }
        get();
    }
})();
